<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" remeasure Modules remeasure Source: index.js // external dependencies import isArray from 'lodash/isArray'; import isFunction from 'lodash/isFunction'; import isPlainObject from 'lodash/isPlainObject'; import isString from 'lodash/isString'; // constants import { ALL_KEYS } from './constants'; // component import getMeasuredComponent from './getMeasuredComponent'; // utils import { createFlattenConvenienceFunction, getKeysFromStringKey, getValidKeys } from './utils'; /** * @module remeasure */ /** * @function measure * * @description * create higher-order component that injects size and position properties * into OriginalComponent as an object under the prop name size and position * * @param {Component|Array&lt;string&gt;|Object|string} passedKeys if used without parameters, the component that will be * measured, else either single key or array of keys to watch for measurement, or an object of options * @param {Object} [passedOptions={}] an object of options to apply for measuring * @returns {MeasuredComponent} the higher-order component that will measure the child and pass down size and * position values as props */ const measure = (passedKeys, passedOptions = {}) =&gt; { if (isFunction(passedKeys)) { return getMeasuredComponent(ALL_KEYS, passedOptions)(passedKeys); } const isKeysObject = isPlainObject(passedKeys); const options = isKeysObject ? {...passedKeys} : {...passedOptions}; if (isKeysObject) { return getMeasuredComponent(ALL_KEYS, passedKeys); } let keys; if (isArray(passedKeys)) { keys = getValidKeys(passedKeys, ALL_KEYS); } else if (isString(passedKeys)) { keys = getKeysFromStringKey(passedKeys, options); } else { keys = ALL_KEYS; } return getMeasuredComponent(keys, options); }; ALL_KEYS.forEach((key) =&gt; { measure[key] = createFlattenConvenienceFunction(measure, key); }); export default measure; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" remeasure Modules remeasure Modules × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" remeasure Modules remeasure remeasure 2.1.2 remeasure Get position and size of the DOM element for any React Component Table of contents Installation Usage Advanced usage Convenience methods Caveats Support Development Installation $ npm i remeasure --saveUsage // ES2015 import measure from 'remeasure'; // CommonJS const measure = require('remeasure'); // script var measure = window.Remeasure; // apply it as a decorator @measure class MyComponent extends React.Component { render() { const { position, size } = this.props; return ( &lt;div&gt; I have access to my size and position through props! &lt;/div&gt; ); } } // or as a function wrapper const StatelessComponent = measure(({position, size}) =&gt; { return ( &lt;div&gt; In here too! &lt;/div&gt; ); });Any component that has measure applied to it will be wrapped in a Higher-Order Component that will pass in the props position and size, which contain a variety of measurements related to (you guessed it) the component's position and size. A complete list of properties: { position: { bottom: Number, clientLeft: Number, clientTop: Number, offsetLeft: Number, offsetTop: Number, left: Number, right: Number, scrollLeft: Number, scrollTop: Number, top: Number }, size: { clientHeight: Number, clientWidth: Number, height: Number, naturalHeight: Number, naturalWidth: Number, offsetHeight: Number, offsetWidth: Number, scrollHeight: Number, scrollWidth: Number, width: Number } }The bottom, left, right, and top properties in position are what you would expect from the result of element.getBoundingClientRect(). naturalHeight and naturalWidth are properties that are native to img elements, and for all non-img elements they are coalesced with scrollHeight and scrollWidth, respectively. These properties are retrieved on mount, but will also automatically update if the element is resized thanks to element-resize-event. Please note that elements that do not support content (such as img) are not supported by this resize listener; in the case that you need to support those elements, simply create a higher-order component that wraps that element in a div and decorate that component. Advanced usage If you want to limit the items that are injected into the component, you can pass either a key or array of keys to the decorator before wrapping the component. measure(String|Array&lt;String&gt;|Object[, Object]) returns Function Examples: import measure from 'remeasure'; // pass a string value for a single property const measureOnlyOffsetWidth = measure('offsetWidth'); const MyStatelessComponent = measureOnlyOffsetWidth(({size}) =&gt; { return ( &lt;div&gt; Only size is injected (because no position values were requested), with offsetWidth as the only property &lt;/div&gt; ); }); // or an array of string values for multiple properties @measure(['top', 'height']) class MyComponent extends Component { render() { const { position, size } = this.props; return ( &lt;div&gt; Both the position and size props are injected (because values from both position and size were requested), and each will have a single property on them (top on position, height on size). &lt;/div&gt; ); } } // or quickly select the complete list of either size or position @measure('size') class MySizedComponent extends Component { render() { const size = this.props.size; return ( &lt;div&gt; I have the size prop injected with all properties, but not position. &lt;/div&gt; ); } }You can also pass an object with any of the following propeties (defaults shown): { // value in milliseconds to debounce rerenders debounce: Number, // should the properties not be grouped under position / size flatten: Boolean = false, // sets position property name positionProp: String = 'position', // should element rerender when resized renderOnResize: Boolean = true, // sets size property name sizeProp: String = 'size' }These will serve as options for the instance remeasure is applied to. For example, if you want all position-related properties to be injected under the prop foo and the size-related properties to be injected under the prop bar, you can do this: // use the options by themselves @measure({positionProp: 'foo', sizeProp: 'bar'}) class MyComponent extends Component { render() { const { foo, bar } = this.props; return ( &lt;div&gt; The foo and bar props now represent position and size, respectively. &lt;/div&gt; ); } } // or you can use them with keys const measureWithKeysAndOptions = measure(['height', 'width'], {debounce: 50, flatten: true}); const MyStatelessComponent = measureWithKeysAndOptions(({height, width}) =&gt; { return ( &lt;div&gt; You can still pass options when you want to specify keys, as the second parameter. &lt;/div&gt; ); }; // you can even use the custom props with the shorthand notation @measure('bar', {sizeProp: 'bar'}) class MySizedComponent extends Component { render() { return ( &lt;div&gt; I will have access to all the size properties under the prop bar, but foo will not be injected. &lt;/div&gt; ); } }Convenience methods For each key that is measured, a convenience function exists on the main measure function which is a shorthand for measure(property, {flatten: true}). Example: @measure.width class MyMeasuredComponent extends Component { render() { return ( &lt;div&gt; I have access to width at this.props.width. &lt;/div&gt; ); } }These accept options as a parameter just like the standard measure, they are just merged with the flatten: true value. Caveats A couple things to keep in mind when using remeasure: Void tags cannot detect element resize If children on a tag are considered invalid HTML (such as for &lt;input/&gt;, &lt;img/&gt;, etc), then the internal element resize detector cannot not work. The easy solution to this is to update the component via props (on update a recalculation of values is triggered). Components may render twice on update If you perform an update to the component props or state that also happens to change its dimensions, the component will update twice, once for the changes to props / state, and again for the changes to its dimensions. This is because the component needs to render in the DOM before updated values can be calculated. Support remeasure has been tested and confirmed to work on the following browsers: Chrome Firefox Opera Edge IE9+ remeasure also works with universal / isomorphic applications. Development Standard stuff, clone the repo and npm i to get the dependencies. npm scripts available: build =&gt; builds the distributed JS with NODE_ENV=development and with sourcemaps build-minified =&gt; builds the distributed JS with NODE_ENV=production and minified compile-for-publish =&gt; runs the lint, test, transpile, dist scripts dev =&gt; runs the webpack dev server for the playground dist =&gt; runs the build and build-minified lint =&gt; runs ESLint against files in the src folder prepublish =&gt; if in publish, runs compile-for-publish test =&gt; run ava with NODE_ENV=test test:watch =&gt; runs test but with persistent watcher transpile =&gt; runs Babel against files in src to files in lib × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-remeasure.html":{"id":"module-remeasure.html","title":"Module: remeasure","body":" remeasure Modules remeasure Module: remeasure Source: index.js, line 43 Methods &lt;inner&gt; measure(passedKeys [, passedOptions]) create higher-order component that injects size and position properties into OriginalComponent as an object under the prop name size and position Parameters: Name Type Argument Default Description passedKeys Component | Array.&lt;string&gt; | Object | string if used without parameters, the component that will be measured, else either single key or array of keys to watch for measurement, or an object of options passedOptions Object &lt;optional&gt; {} an object of options to apply for measuring Source: index.js, line 47 Returns: the higher-order component that will measure the child and pass down size and position values as props Type MeasuredComponent × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
