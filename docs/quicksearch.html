<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" remeasure Modules remeasure Global getShouldClearremoveElementResize Source: utils.js // external dependencies import debounce from 'lodash/debounce'; import filter from 'lodash/filter'; import includes from 'lodash/includes'; import isFunction from 'lodash/isFunction'; import isNull from 'lodash/isNull'; import isUndefined from 'lodash/isUndefined'; import reduce from 'lodash/reduce'; import some from 'lodash/some'; import raf from 'raf'; import { findDOMNode } from 'react-dom'; // constants import { ALL_BOUNDING_CLIENT_RECT_KEYS, ALL_DOM_ELEMENT_KEYS, ALL_POSITION_KEYS, ALL_SIZE_KEYS, CLIENT_RECT_TYPE, DEBOUNCE_VALUE_DEFAULT, DEFAULT_INSTANCE_ELEMENT_VALUE, DEFAULT_INSTANCE_RESIZE_LISTENER, ELEMENT_RESIZE_DETECTOR, ELEMENT_TYPE, NATURAL_REGEXP, POSITION_PROP_DEFAULT, RENDER_ON_RESIZE_DEFAULT, SIZE_PROP_DEFAULT, VOID_ELEMENT_TAG_NAMES } from './constants'; /** * @private * * @function getComponentName * * @description * get the name of the component from displayName, the internal name, or fallback * * @param {Component} Component component to get the display name from * @returns {string} Component name */ export const getComponentName = (Component) =&gt; { return Component.displayName || Component.name || 'Component'; }; /** * @private * * @function haveValuesChanged * * @description * iterate through keys and determine if the values have * changed compared to what is stored in state * * @param {Array&lt;Object&gt;} keys keys to get from the state * @param {Object} values the new values to test * @param {Object} currentState the current values in state * @returns {boolean} have any of the keys changed */ export const haveValuesChanged = (keys, values, currentState) =&gt; { return some(keys, ({key}) =&gt; { return values[key] !== currentState[key]; }); }; /** * @private * * @function setValuesIfChanged * * @description * if the values have changed and the instance is mounted then set the values in state * * @param {MeasuredComponent} instance component instance * @param {function} instance.setState setState method of instance component * @param {Array&lt;string&gt;} keys keys to store in state * @param {Object} values updated values to store in state */ export const setValuesIfChanged = (instance, keys, values) =&gt; { if (haveValuesChanged(keys, values, instance.state) &amp;&amp; instance.element) { instance.setState(values); } }; /** * @private * * @function reduceStateToMatchingKeys * * @description * based on desiredKeys, build the initialState object * * @param {Array&lt;string&gt;} keys the keys requested from the decorator * @returns {Array&lt;T&gt;} the object of key: 0 default values */ export const reduceStateToMatchingKeys = (keys) =&gt; { return reduce(keys, (accumulatedInitialState, {key}) =&gt; { accumulatedInitialState[key] = 0; return accumulatedInitialState; }, {}); }; /** * @function getShouldClear * * @description * get whether the values should be cleared or not based on values in state * * @param {Object} state the current state values * @param {Array&lt;Object&gt;} selectedKeys the keys to iterate over * @returns {boolean} should the values be cleared or not */ export const getShouldClear = (state, selectedKeys) =&gt; { const length = selectedKeys.length; let index = -1; while (++index &lt; length) { if (state[selectedKeys[index].key]) { return true; } } return false; }; /** * @private * * @function clearValues * * @description * create function to reset all values to 0 if there is no element present * * @param {MeasuredComponent} instance component instance * @param {Array&lt;string&gt;} selectedKeys keys to store in state */ export const clearValues = (instance, selectedKeys) =&gt; { if (getShouldClear(instance.state, selectedKeys)) { const emptyValues = reduceStateToMatchingKeys(selectedKeys); instance.setState(emptyValues); } }; /** * @private * * @function createUpdateValuesViaDebounce * * @description * create the function to update the values via debounce value * * @param {MeasuredComponent} instance component instance * @param {number} debounceValue debounce value for the instance provided * @returns {function(): void} function to update the values after debounce timing has passed */ export const createUpdateValuesViaDebounce = (instance, debounceValue) =&gt; { return debounce(() =&gt; { if (instance.element) { instance.updateValuesIfChanged(); } }, debounceValue); }; /** * @private * * @function createUpdateValuesViaRaf * * @description * create the function to update the values via requestAnimationFrame * * @param {MeasuredComponent} instance component instance */ export const updateValuesViaRaf = (instance) =&gt; { if (instance.element) { raf(instance.updateValuesIfChanged); } }; /** * @private * * @function isElementVoidTag * * @description * is the element passed a void tag name * * @param {HTMLElement} element * @returns {boolean} */ export const isElementVoidTag = (element) =&gt; { return includes(VOID_ELEMENT_TAG_NAMES, element.tagName.toUpperCase()); }; /** * @private * * @function setElementResize * * @description * create the function to assign the onResize listener to the element * * @param {MeasuredComponent} instance component instance * @param {number} debounceValue debounce value for the instance provided */ export const setElementResize = (instance, debounceValue) =&gt; { const element = instance.element; if (element &amp;&amp; !isElementVoidTag(element)) { const resizeFn = debounceValue ? createUpdateValuesViaDebounce(instance, debounceValue) : updateValuesViaRaf.bind(null, instance); ELEMENT_RESIZE_DETECTOR.listenTo(element, resizeFn); instance.resizeListener = resizeFn; } }; /** * @function removeElementResize * * @description * remove listeners from the given element * * @param {MeasuredComponent} instance component instance * @param {HTMLElement} element element to remove listeners from */ export const removeElementResize = (instance, element) =&gt; { instance.resizeListener = DEFAULT_INSTANCE_RESIZE_LISTENER; if (element) { ELEMENT_RESIZE_DETECTOR.uninstall(element); } }; /** * @private * * @function setElement * * @description * assign the element to the instance * * @param {MeasuredComponent} instance component instance * @param {HTMLElement|null} element element to assign to instance * @param {number} debounceValue debounce value for the instance provided * @param {boolean} renderOnResize should the component rerender on resize */ export const setElement = (instance, element, debounceValue, renderOnResize) =&gt; { const currentElement = instance.element; instance.element = element; if (instance.element) { if (renderOnResize &amp;&amp; !instance.resizeListener) { setElementResize(instance, debounceValue); } } else { removeElementResize(instance, currentElement); } }; /** * @private * * @function createRemoveInstanceElement * * @description * reset instance values to their original state * * @param {MeasuredComponent} instance component instance * @returns {function(): void} function to reset the instance values to defaults */ export const createRemoveInstanceElement = (instance) =&gt; { return () =&gt; { if (instance.element) { removeElementResize(instance, instance.element); instance.element = DEFAULT_INSTANCE_ELEMENT_VALUE; } }; }; /** * @private * * @function createSetInstanceElement * * @description * create the componentDidUpdate method for the given instance * * @param {MeasuredComponent} instance component instance * @param {Array&lt;string&gt;} selectedKeys keys to store in state * @param {Object} [options={}] options passed to the instance * @param {number} [options.debounceValue=DEBOUNCE_VALUE_DEFAULT] value to use for debounce of updates * @param {boolean} [options.renderOnResize=RENDER_ON_RESIZE_DEFAULT] should the component rerender on resize * @returns {function(): void} componentDidUpdate method */ export const createSetInstanceElement = (instance, selectedKeys, options = {}) =&gt; { const { debounce: debounceValue = DEBOUNCE_VALUE_DEFAULT, renderOnResize = RENDER_ON_RESIZE_DEFAULT } = options; return () =&gt; { const element = findDOMNode(instance); if (element !== instance.element) { setElement(instance, element, debounceValue, renderOnResize); } if (element) { updateValuesViaRaf(instance); } else { clearValues(instance, selectedKeys); } }; }; /** * @private * * @function createIsKeyType * * @description * create a key type checker function * * @param {Array&lt;string&gt;} typeArray * @returns {function(string): boolean} */ export const createIsKeyType = (typeArray) =&gt; { return (key) =&gt; { return includes(typeArray, key); }; }; /** * @private * * @function createFlattenConvenienceFunction * * @description * create a convenience function that will flatten the values returned (specific to property if passed) * * @param {function} measure main measure function to get the decorator from * @param {string} property specific property to build convenience function for * @returns {function((function|Object), Object): function} decorator with flatten added as option */ export const createFlattenConvenienceFunction = (measure, property) =&gt; { return (component, options = {}) =&gt; { const isComponentFunction = isFunction(component); const decoratorOptions = isComponentFunction ? options : component; const decorator = measure(property, { ...decoratorOptions, flatten: true }); return isComponentFunction ? decorator(component) : decorator; }; }; /** * @private * * @function getScopedValues * * @description * based on the keys passed, create an object with either position * or size or both properties that are objects containing the respective * values for the associated keys * * @param {Object} values values to reduce by type * @param {Array&lt;string&gt;} keys the keys to assign to scopedValues * @param {boolean} flatten should the object be flat or not * @returns {Object} reduced scoped values */ export const getScopedValues = (values, keys, {flatten}) =&gt; { return flatten ? values : reduce(keys, (scopedValues, {key, type}) =&gt; { if (!scopedValues[type]) { scopedValues[type] = {}; } scopedValues[type][key] = values[key]; return scopedValues; }, {}); }; /** * @private * * @function getNaturalDimensionValue * * @description * For naturalHeight and naturalWidth, coalesce the values * with scrollHeight and scrollWIdth if the element does not * natively support it * * @param {HTMLElement} source the element to get the size / position value from * @param {string} key the size / position value to retrieve from source * @returns {number} */ export const getNaturalDimensionValue = (source, key) =&gt; { const value = source[key]; return isUndefined(value) ? source[key.replace(NATURAL_REGEXP, 'scroll')] : value; }; /** * @private * * @function getElementValues * * @description * get the values of the element or its bounding client rect * * @param {HTMLElement} element * @param {Array&lt;Object&gt;} keys * @returns {Object} */ export const getElementValues = (element, keys) =&gt; { const boundingClientRect = element.getBoundingClientRect(); return reduce(keys, (values, {key, source}) =&gt; { values[key] = source === CLIENT_RECT_TYPE ? boundingClientRect[key] : getNaturalDimensionValue(element, key); return values; }, {}); }; /** * @private * * @function createUpdateValuesIfChanged * * @description * create the function to get the new values and assign them to state if they have changed * * @param {MeasuredComponent} instance component instance * @param {Array&lt;string&gt;} selectedKeys keys to store in state * @returns {function(): void} function to update the instance state values if they have changed */ export const createUpdateValuesIfChanged = (instance, selectedKeys) =&gt; { return () =&gt; { const element = instance.element; if (element) { const values = getElementValues(element, selectedKeys); setValuesIfChanged(instance, selectedKeys, values); } }; }; /** * @private * * @function getPropKeyNames * * @description * get the positionProp and sizeProp properties from options with defaults applied * * @param {string} [positionProp=POSITION_PROP_DEFAULT] position property name * @param {string} [sizeProp=SIZE_PROP_DEFAULT] size property name * @returns {{positionProp, sizeProp}} object of positionProp and sizeProp */ export const getPropKeyNames = ({positionProp = POSITION_PROP_DEFAULT, sizeProp = SIZE_PROP_DEFAULT}) =&gt; { return { positionProp, sizeProp }; }; /** * @private * * @function isPositionKey * * @description * is the key passed a position key * * @param {string} key * @returns {boolean} */ export const isPositionKey = createIsKeyType(ALL_POSITION_KEYS); /** * @private * * @function isSizeKey * * @description * is the key passed a size key * * @param {string} key * @returns {boolean} */ export const isSizeKey = createIsKeyType(ALL_SIZE_KEYS); /** * @private * * @function getKeyType * * @description * get the type (position or size) of the key passed * * @param {string} key * @param {string} positionProp * @param {string} sizeProp * @returns {string} */ export const getKeyType = (key, {positionProp, sizeProp}) =&gt; { if (isPositionKey(key)) { return positionProp; } if (isSizeKey(key)) { return sizeProp; } return null; }; /** * @private * * @function getKeysFromStringKey * * @description * get the keys to store in state based on the key and options passed * * @param {string} key string key passed to decorator * @param {string} [positionProp=POSITION_PROP_DEFAULT] name of position property requested in options * @param {string} [sizeProp=SIZE_PROP_DEFAULT] name of position property requested in options * @returns {Array&lt;string&gt;} keys to store in state */ export const getKeysFromStringKey = (key, {positionProp = POSITION_PROP_DEFAULT, sizeProp = SIZE_PROP_DEFAULT}) =&gt; { if (key === positionProp) { return ALL_POSITION_KEYS; } if (key === sizeProp) { return ALL_SIZE_KEYS; } return [key]; }; /** * @private * * @function getKeysSubsetWithType * * @description * get subset of array1 based on items existing in array2 * * @param {Array&lt;*&gt;} sourceArray the array to filter * @param {Array&lt;*&gt;} valuesToExtract the array to find matches in * @param {string} source the source of the value the key relates to * @param {{positionProp: string, sizeProp: string}} propTypes the names of the scope categories * @returns {Array&lt;T&gt;} the resulting array of matching values from array1 and array2 */ export const getKeysSubsetWithType = (sourceArray, valuesToExtract, source, propTypes) =&gt; { return reduce(sourceArray, (valuesWithTypes, key) =&gt; { if (includes(valuesToExtract, key)) { const type = getKeyType(key, propTypes); if (!isNull(type)) { valuesWithTypes.push({ key, source, type }); } } return valuesWithTypes; }, []); }; /** * @private * * @function getKeysWithSourceAndType * * @description * get the keys with mapped source (rect or element) and type (position or size) * * @param {Array&lt;string&gt;} keys keys to return mapped values for * @param {Object} options options passed to instance * @returns {Array&lt;{key: string, source: string, type: string}&gt;} keys with source and type mapped */ export const getKeysWithSourceAndType = (keys, options) =&gt; { const propKeyNames = getPropKeyNames(options); return [ ...getKeysSubsetWithType(ALL_BOUNDING_CLIENT_RECT_KEYS, keys, CLIENT_RECT_TYPE, propKeyNames), ...getKeysSubsetWithType(ALL_DOM_ELEMENT_KEYS, keys, ELEMENT_TYPE, propKeyNames) ]; }; /** * @private * * @description * based on their existence in keysToTestAgainst, determine which of the keys * passed are considered valid * * @param {Array&lt;string&gt;} keys the keys to test * @param {Array&lt;string&gt;} keysToTestAgainst the keys to find matches from * @returns {Array&lt;string&gt;} the resulting matching key set */ export const getValidKeys = (keys, keysToTestAgainst) =&gt; { return filter(keys, (key) =&gt; { return includes(keysToTestAgainst, key); }); }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" remeasure Modules remeasure Global getShouldClearremoveElementResize Source: index.js // external dependencies import isArray from 'lodash/isArray'; import isFunction from 'lodash/isFunction'; import isPlainObject from 'lodash/isPlainObject'; import isString from 'lodash/isString'; // constants import { ALL_KEYS } from './constants'; // component import getMeasuredComponent from './getMeasuredComponent'; // utils import { createFlattenConvenienceFunction, getKeysFromStringKey, getValidKeys } from './utils'; /** * @module remeasure */ /** * @function measure * * @description * create higher-order component that injects size and position properties * into OriginalComponent as an object under the prop name size and position * * @param {Component|Array&lt;string&gt;|Object|string} passedKeys if used without parameters, the component that will be * measured, else either single key or array of keys to watch for measurement, or an object of options * @param {Object} [passedOptions={}] an object of options to apply for measuring * @returns {MeasuredComponent} the higher-order component that will measure the child and pass down size and * position values as props */ const measure = (passedKeys, passedOptions = {}) =&gt; { if (isFunction(passedKeys)) { return getMeasuredComponent(ALL_KEYS, passedOptions)(passedKeys); } const isKeysObject = isPlainObject(passedKeys); const options = { ...(isKeysObject ? passedKeys : passedOptions) }; if (isKeysObject) { return getMeasuredComponent(ALL_KEYS, passedKeys); } let keys; if (isArray(passedKeys)) { keys = getValidKeys(passedKeys, ALL_KEYS); } else if (isString(passedKeys)) { keys = getKeysFromStringKey(passedKeys, options); } else { keys = ALL_KEYS; } return getMeasuredComponent(keys, options); }; ALL_KEYS.forEach((key) =&gt; { measure[key] = createFlattenConvenienceFunction(measure, key); }); export default measure; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" remeasure Modules remeasure Global getShouldClearremoveElementResize Global Methods getShouldClear(state, selectedKeys) get whether the values should be cleared or not based on values in state Parameters: Name Type Description state Object the current state values selectedKeys Array.&lt;Object&gt; the keys to iterate over Source: utils.js, line 131 Returns: should the values be cleared or not Type boolean removeElementResize(instance, element) remove listeners from the given element Parameters: Name Type Description instance MeasuredComponent component instance element HTMLElement element to remove listeners from Source: utils.js, line 248 × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" remeasure Modules remeasure Global getShouldClearremoveElementResize Modules × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" remeasure Modules remeasure Global getShouldClearremoveElementResize remeasure 2.2.0 remeasure Get position and size of the DOM element for any React Component Table of contents Installation Usage Advanced usage Convenience methods Caveats Support Development Installation $ npm i remeasure --saveUsage // ES2015 import measure from 'remeasure'; // CommonJS const measure = require('remeasure'); // script var measure = window.Remeasure; // apply it as a decorator @measure class MyComponent extends React.Component { render() { const { position, size } = this.props; return ( &lt;div&gt; I have access to my size and position through props! &lt;/div&gt; ); } } // or as a function wrapper const StatelessComponent = measure(({position, size}) =&gt; { return ( &lt;div&gt; In here too! &lt;/div&gt; ); });Any component that has measure applied to it will be wrapped in a Higher-Order Component that will pass in the props position and size, which contain a variety of measurements related to (you guessed it) the component's position and size. A complete list of properties: { position: { bottom: Number, clientLeft: Number, clientTop: Number, offsetLeft: Number, offsetTop: Number, left: Number, right: Number, scrollLeft: Number, scrollTop: Number, top: Number }, size: { clientHeight: Number, clientWidth: Number, height: Number, naturalHeight: Number, naturalWidth: Number, offsetHeight: Number, offsetWidth: Number, scrollHeight: Number, scrollWidth: Number, width: Number } }The bottom, left, right, and top properties in position are what you would expect from the result of element.getBoundingClientRect(). naturalHeight and naturalWidth are properties that are native to img elements, and for all non-img elements they are coalesced with scrollHeight and scrollWidth, respectively. These properties are retrieved on mount, but will also automatically update if the element is resized thanks to element-resize-event. Please note that elements that do not support content (such as img) are not supported by this resize listener; in the case that you need to support those elements, simply create a higher-order component that wraps that element in a div and decorate that component. Advanced usage If you want to limit the items that are injected into the component, you can pass either a key or array of keys to the decorator before wrapping the component. measure(String|Array&lt;String&gt;|Object[, Object]) returns Function Examples: import measure from 'remeasure'; // pass a string value for a single property const measureOnlyOffsetWidth = measure('offsetWidth'); const MyStatelessComponent = measureOnlyOffsetWidth(({size}) =&gt; { return ( &lt;div&gt; Only size is injected (because no position values were requested), with offsetWidth as the only property &lt;/div&gt; ); }); // or an array of string values for multiple properties @measure(['top', 'height']) class MyComponent extends Component { render() { const { position, size } = this.props; return ( &lt;div&gt; Both the position and size props are injected (because values from both position and size were requested), and each will have a single property on them (top on position, height on size). &lt;/div&gt; ); } } // or quickly select the complete list of either size or position @measure('size') class MySizedComponent extends Component { render() { const size = this.props.size; return ( &lt;div&gt; I have the size prop injected with all properties, but not position. &lt;/div&gt; ); } }You can also pass an object with any of the following propeties (defaults shown): { // value in milliseconds to debounce rerenders debounce: Number, // should the properties not be grouped under position / size flatten: Boolean = false, // sets position property name positionProp: String = 'position', // should element rerender when resized renderOnResize: Boolean = true, // sets size property name sizeProp: String = 'size' }These will serve as options for the instance remeasure is applied to. For example, if you want all position-related properties to be injected under the prop foo and the size-related properties to be injected under the prop bar, you can do this: // use the options by themselves @measure({positionProp: 'foo', sizeProp: 'bar'}) class MyComponent extends Component { render() { const { foo, bar } = this.props; return ( &lt;div&gt; The foo and bar props now represent position and size, respectively. &lt;/div&gt; ); } } // or you can use them with keys const measureWithKeysAndOptions = measure(['height', 'width'], {debounce: 50, flatten: true}); const MyStatelessComponent = measureWithKeysAndOptions(({height, width}) =&gt; { return ( &lt;div&gt; You can still pass options when you want to specify keys, as the second parameter. &lt;/div&gt; ); }; // you can even use the custom props with the shorthand notation @measure('bar', {sizeProp: 'bar'}) class MySizedComponent extends Component { render() { return ( &lt;div&gt; I will have access to all the size properties under the prop bar, but foo will not be injected. &lt;/div&gt; ); } }Convenience methods For each key that is measured, a convenience function exists on the main measure function which is a shorthand for measure(property, {flatten: true}). Example: @measure.width class MyMeasuredComponent extends Component { render() { return ( &lt;div&gt; I have access to width at this.props.width. &lt;/div&gt; ); } }These accept options as a parameter just like the standard measure, they are just merged with the flatten: true value. Caveats A couple things to keep in mind when using remeasure: Void tags cannot detect element resize If children on a tag are considered invalid HTML (such as for &lt;input/&gt;, &lt;img/&gt;, etc), then the internal element resize detector cannot not work. The easy solution to this is to update the component via props (on update a recalculation of values is triggered). Components may render twice on update If you perform an update to the component props or state that also happens to change its dimensions, the component will update twice, once for the changes to props / state, and again for the changes to its dimensions. This is because the component needs to render in the DOM before updated values can be calculated. Support remeasure has been tested and confirmed to work on the following browsers: Chrome Firefox Opera Edge IE9+ remeasure also works with universal / isomorphic applications. Development Standard stuff, clone the repo and npm i to get the dependencies. npm scripts available: build =&gt; builds the distributed JS with NODE_ENV=development and with sourcemaps build-minified =&gt; builds the distributed JS with NODE_ENV=production and minified compile-for-publish =&gt; runs the lint, test, transpile, dist scripts dev =&gt; runs the webpack dev server for the playground dist =&gt; runs the build and build-minified lint =&gt; runs ESLint against files in the src folder prepublish =&gt; if in publish, runs compile-for-publish test =&gt; run ava with NODE_ENV=test test:watch =&gt; runs test but with persistent watcher transpile =&gt; runs Babel against files in src to files in lib × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-remeasure.html":{"id":"module-remeasure.html","title":"Module: remeasure","body":" remeasure Modules remeasure Global getShouldClearremoveElementResize Module: remeasure Source: index.js, line 43 Methods &lt;inner&gt; measure(passedKeys [, passedOptions]) create higher-order component that injects size and position properties into OriginalComponent as an object under the prop name size and position Parameters: Name Type Argument Default Description passedKeys Component | Array.&lt;string&gt; | Object | string if used without parameters, the component that will be measured, else either single key or array of keys to watch for measurement, or an object of options passedOptions Object &lt;optional&gt; {} an object of options to apply for measuring Source: index.js, line 47 Returns: the higher-order component that will measure the child and pass down size and position values as props Type MeasuredComponent × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
